# javascript

## 목차  

### [1. 데이터 타입은 어떤 것이 있는가?](#1-데이터-타입은-어떤-것이-있는가-1)  
### [2. "this" 키워드의 역할은 무엇인가?](#2-this-키워드의-역할은-무엇인가-1)  
### [3. 클로저란 무엇이고 어떻게 사용하는가?](#3-클로저란-무엇이고-어떻게-사용하는가-1)  
### [4. "prototype"과 "class"의 차이점은 무엇인가?](#4-prototype과-class의-차이점은-무엇인가-1)  
### [5. "호이스팅"은 무엇이고 어떻게 동작하는가?](#5-호이스팅은-무엇이고-어떻게-동작하는가-1)  
### [6. "비동기" 처리 방법은 무엇이 있는가?](#6-비동기-처리-방법은-무엇이-있는가-1)  
### [7. "콜백"함수는 무엇이고 어떻게 사용하는가?](#7-콜백함수는-무엇이고-어떻게-사용하는가-1)  
### [8. "Promise"는 무엇이고 어떻게 사용하는가?](#8-promise는-무엇이고-어떻게-사용하는가-1)  
### [9. "async/await"는 무엇이고 어떻게 사용하는가?](#9-asyncawait는-무엇이고-어떻게-사용하는가-1)  
### [10. "ES6"의 주요 기능들은 무엇이 있는가?](#10-es6의-주요-기능들은-무엇이-있는가-1)  

---

## 1. 데이터 타입은 어떤 것이 있는가?  

- 데이터 타입은 크게 원시형, 참조형 2가지로 구분할 수 있습니다.  
- 원시형은 숫자, 문자열, Boolean, null, undefined, null 등이 있습니다.
- 참조형은 객체, 배열, 함수 등이 있습니다.  

<br />

### 1-1. 원시형과 참조형 타입의 차이는 무엇인가?

- 원시형 타입은 immutable(불변)합니다. 즉, 새로운 값을 할당하면 이전 값이 변경되는 것이 아니라 새로운 메모리 공간을 차지하게 됩니다.  
ex) a라는 변수에 3을 할당했다가, 10을 새로 할당할 시, 기존에 있던 3이라는 값이 변경되는 것이 아닌 10이라는 새로운 값을 가리키게 됩니다.  

- 참조형 타입은 mutable(가변)합니다. 변수에 할당된 값은 값 그 자체가 아닌, 값이 저장된 주소를 기억합니다. 따라서, 참조형 타입을 할당한
변수를 다른 변수에 할당할 경우, 같은 참조형 값을 공유하게 됩니다.  
ex) a라는 변수에 배열을 할당하고, b라는 변수에 a를 할당할 시, 해당 배열에 값이 추가하면 변수 a, b의 배열 모두 변경됩니다.  

<br />

### 1-2. 원시형과 참조형의 저장 방식의 차이는 무엇인가?

- 원시형 타입은 값 자체가 변수에 저장됩니다. 원시형 타입은 stack에 저장이 되고, 변수에는 이 stack에 저장된 자료의 값이 할당됩니다. 원시형은
불변(immutable)하므로, 만약 변수에 새로운 값이 할당될 시, stack에 저장된 값이 변경되는 것이 아니라,  stack의 새로운 공간에 값이 변경되고,
변수는 새로운 공간을 가리키게 됩니다.

- 참조형 타입은 값이 저장된 메모리의 주소가 변수에 저장됩니다. 참조형 타입은 heap에 저장이 되고, stack에는 heap에 저장된 값의 주소가 저장됩니다.
만약 변수에 새로운 값이 추가되거나, 값이 변경되더라도 heap에 저장된 값만 바뀌므로 변수에 할당된 주소 값에는 영향을 주지 않습니다.

- stack => 원시형 값, heap에 저장된 참조형 값의 주소 값을 저장합니다.

- heap => 참조형 값을 저장합니다.  

<br />

### 1-3. 참조형 타입을 할당한 변수에 새로운 참조형 값을 할당할 때 무슨 일이 일어나는가?

- 해당 변수는 stack에 새롭게 생겨난 참조형 값의 주소를 저장하게 됩니다. 기존 heap에 저장된 참조형 값은 어떠한 변수에서도 참조되지 않을 시,
가비지 컬렉터에 의해 삭제 되게 됩니다.  

<br />

### 1-4. 가비지 컬렉터가 무엇인가?

- 자바스크립트 엔진 내부에서 실행되는 메모리 관리 기능 중 하나 입니다.

- 개발자가 직접 제어하지 않아도, 자동으로 더 이상 사용하지 않는 메모리를 해제해줍니다.

<br />

### 1-5. undefined와 null, undeclared의 차이는 무엇인가?

- undefined와 null은 공통적으로 값이 없음을 나타냅니다. 하지만 null은 다소 의도성이 포함되어 있다고 볼 수 있습니다.

- undefined는 변수가 선언되었지만, 어떠한 값도 할당되지 않았음을 의미합니다. 또한 함수 내에서 인자가 전달되지 않았을 때에도 
undefined가 할당 됩니다.

- 프로그래머가 변수에 아무것도 할당하지 않을 것임을 명시적으로 나타내거나, 객체 내에서 프로퍼티가 존재하지 않을 경우 null이 반환됩니다.

- undeclared는 변수 자체가 선언되지 않았음을 의미합니다. 변수를 선언하지 않아, referenceError가 뜨는 상황을 예시로 들 수 있습니다.

<br />

### [목차로 이동](#목차)


---
## 2. "this" 키워드의 역할은 무엇인가?  

- 현재 실행 중인 함수 또는 메서드에서 현재 객체를 참조하는 데에 사용됩니다.

- 현재 객체의 접근하거나 수정할 수 있습니다.

<br />

### 2-1. "this" 키워드가 결정되는 방식은 무엇인가?

- "this" 키워드는 호출 방식에 따라 값이 다르게 결정됩니다.

- 함수 호출에서의 "this"는 전역 객체를 의미합니다. 브라우저에서는 "window" 객체가 전역 객체를 의미합니다.

- 객체의 메서드로 호출될 때의 "this"는 해당 객체를 의미합니다.

- 생성자에서의 "this"는 새로 생성될 객체를 의미합니다.

- "apply()" 또는 "call()"에서 "this"는 함수에 전달된 첫 번째 인수로 지정된 객체를 의미합니다.

- 화살표 함수에서 "this"는 해당 함수를 둘러싸는 가장 가까운 일반 함수의 "this"를 의미합니다.

<br />

### 2-2. "apply()"와 "call()"을 차이는 무엇인가?

- 함수에 인자를 전달하는 방식에서 차이점이 있습니다.

- apply는 배열 형태로 인자를 전달합니다. (모든 인자를 하나의 배열에 모두 담아야 합니다) <br />
보통 인자의 숫자가 가변적일 때 사용합니다.

- call은 일반적인 인자를 나열하여 전달합니다. (인자를 나열하기만 하면 됩니다)

<br />

### 2-3. 화살표 함수란 무엇인가?

- ES6문법에서 등장한 새로운 함수 선언 방식입니다.

- 익명함수로 사용되며, 코드량이 줄어들고 가독성이 향상되는 이점이 있습니다.

- 하지만 "this", "arguments"등의 바인딩을 생성하지 않습니다. (상위 함수의 값을 그대로 가져옵니다.)

<br />

### 2-4. "arguments"와 "rest parameter"의 차이점은 무엇인가?

- "arguments"는 함수에 전달된 인자들을 담고 있는 유사 배열입니다. 유사 배열이므로 배열 메서드를 사용할 수 없습니다. <br />
함수내에서 "arguments" 키워드를 통해 접근할 수 있습니다. (단, 화살표 함수는 "argument" 객체가 존재하지 않습니다.)

- "rest parameter"는 인자들 중 마지막에 위치한 것을 나타내며, 인자들을 배열 형태로 전달합니다. 배열 메서드를 사용할 수 있습니다.

<br />

### [목차로 이동](#목차)

---
## 3. 클로저란 무엇이고 어떻게 사용하는가?  

- 함수가 생성될 당시의 환경을 기억하여, 해당 함수가 실행될 경우, 함수가 생성된 당시의 변수를 참조할 수 있는 기능입니다.

<br />

### 3-1. "렉시컬 스코프"란 무엇인가?

- 함수를 어디에 정의하였는지에 따라 결정되는 스코프(변수)입니다. 예를 들어 "test"라는 함수에서 정의된 변수는  <br />
"test" 스코프에 속하게 됩니다.

### 3-2. 현재 "렉시컬 스코프"에서 변수를 찾을 수 없을 경우 어떠한 동작이 일어나는가?

- 현재 "렉시컬 스코프"에서 변수를 찾을 수 없을 경우 상위(외부 함수) 스코프에서 해당 변수를 찾습니다. (스코프 체인이라 부릅니다.)  
- 만약 가장 상위의 스코프에서도 변수를 찾을 수 없을 시 참조 에러(ReferenceError)가 발생합니다.

<br />

### 3-3. 클로저를 사용했을 때의 장점은 무엇인가?

- 데이터 은닉화: 변수를 외부로부터 보호하고, 변수 값의 변경을 방지할 수 있습니다.

- 데이터 보존: 변수가 가비지 컬렉터에 의해 수집되지 않습니다. 따라서 해당 변수에 지속적인 참조가 가능합니다.

<br />

### 3-4. 클로저를 사용했을 때에 발생할 수 있는 문제점은 무엇인가?

- 메모리 누수 : 변수가 지속적인 참조가 가능함에 따라, 메모리에 계속 남아있게 됩니다. 만약 더이상 사용되지 않는 변수라면, <br />
null을 할당하여 가비지 컬렉터에 수집되게 할 수 있습니다. (더이상 참조 불가능)

```
function outerFunction() {
  let someVar = "hello";
  let anotherVar = "world";
  
  function innerFunction() {
    console.log(someVar + " " + anotherVar);
  }
  
  // 클로저를 반환하는 대신 객체를 반환
  return {
    callInnerFunction: function() {
      innerFunction();
    },
    // someVar 변수는 사용이 끝났으므로 null로 할당
    cleanup: function() {
      someVar = null;
    }
  };
}

const closureObject = outerFunction();
closureObject.callInnerFunction();
closureObject.cleanup();
```

<br />

### [목차로 이동](#목차)

---
## 4. "prototype"과 "class"의 차이점은 무엇인가?  
---
## 5. "호이스팅"은 무엇이고 어떻게 동작하는가?  
---
## 6. "비동기" 처리 방법은 무엇이 있는가?  
---
## 7. "콜백"함수는 무엇이고 어떻게 사용하는가?  
---
## 8. "Promise"는 무엇이고 어떻게 사용하는가?  
---
## 9. "async/await"는 무엇이고 어떻게 사용하는가?  
---
## 10. "ES6"의 주요 기능들은 무엇이 있는가?  

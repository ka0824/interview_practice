# javascript

## 목차  

### [1. 데이터 타입은 어떤 것이 있는가?](#1-데이터-타입은-어떤-것이-있는가-1)  
### [2. "this" 키워드의 역할은 무엇인가?](#2-this-키워드의-역할은-무엇인가-1)  
### [3. 클로저란 무엇이고 어떻게 사용하는가?](#3-클로저란-무엇이고-어떻게-사용하는가-1)  
### [4. "prototype"과 "class"의 차이점은 무엇인가?](#4-prototype과-class의-차이점은-무엇인가-1)  
### [5. "호이스팅"은 무엇이고 어떻게 동작하는가?](#5-호이스팅은-무엇이고-어떻게-동작하는가-1)  
### [6. "비동기" 처리 방법은 무엇이 있는가?](#6-비동기-처리-방법은-무엇이-있는가-1)  
### [7. "콜백"함수는 무엇이고 어떻게 사용하는가?](#7-콜백함수는-무엇이고-어떻게-사용하는가-1)  
### [8. "Promise"는 무엇이고 어떻게 사용하는가?](#8-promise는-무엇이고-어떻게-사용하는가-1)  
### [9. "async/await"는 무엇이고 어떻게 사용하는가?](#9-asyncawait는-무엇이고-어떻게-사용하는가-1)  
### [10. "ES6"의 주요 기능들은 무엇이 있는가?](#10-es6의-주요-기능들은-무엇이-있는가-1)  

---

## 1. 데이터 타입은 어떤 것이 있는가?  

- 데이터 타입은 크게 원시형, 참조형 2가지로 구분할 수 있습니다.  
- 원시형은 숫자, 문자열, Boolean, null, undefined, null 등이 있습니다.
- 참조형은 객체, 배열, 함수 등이 있습니다.  

<br />

### 1-1. 원시형과 참조형 타입의 차이는 무엇인가?

- 원시형 타입은 immutable(불변)합니다. 즉, 새로운 값을 할당하면 이전 값이 변경되는 것이 아니라 새로운 메모리 공간을 차지하게 됩니다.  
ex) a라는 변수에 3을 할당했다가, 10을 새로 할당할 시, 기존에 있던 3이라는 값이 변경되는 것이 아닌 10이라는 새로운 값을 가리키게 됩니다.  

- 참조형 타입은 mutable(가변)합니다. 변수에 할당된 값은 값 그 자체가 아닌, 값이 저장된 주소를 기억합니다. 따라서, 참조형 타입을 할당한
변수를 다른 변수에 할당할 경우, 같은 참조형 값을 공유하게 됩니다.  
ex) a라는 변수에 배열을 할당하고, b라는 변수에 a를 할당할 시, 해당 배열에 값이 추가하면 변수 a, b의 배열 모두 변경됩니다.  

<br />

### 1-2. 원시형과 참조형의 저장 방식의 차이는 무엇인가?

- 원시형 타입은 값 자체가 변수에 저장됩니다. 원시형 타입은 stack에 저장이 되고, 변수에는 이 stack에 저장된 자료의 값이 할당됩니다. 원시형은
불변(immutable)하므로, 만약 변수에 새로운 값이 할당될 시, stack에 저장된 값이 변경되는 것이 아니라,  stack의 새로운 공간에 값이 변경되고,
변수는 새로운 공간을 가리키게 됩니다.

- 참조형 타입은 값이 저장된 메모리의 주소가 변수에 저장됩니다. 참조형 타입은 heap에 저장이 되고, stack에는 heap에 저장된 값의 주소가 저장됩니다.
만약 변수에 새로운 값이 추가되거나, 값이 변경되더라도 heap에 저장된 값만 바뀌므로 변수에 할당된 주소 값에는 영향을 주지 않습니다.

- stack => 원시형 값, heap에 저장된 참조형 값의 주소 값을 저장합니다.

- heap => 참조형 값을 저장합니다.  

<br />

### 1-3. 참조형 타입을 할당한 변수에 새로운 참조형 값을 할당할 때 무슨 일이 일어나는가?

- 해당 변수는 stack에 새롭게 생겨난 참조형 값의 주소를 저장하게 됩니다. 기존 heap에 저장된 참조형 값은 어떠한 변수에서도 참조되지 않을 시,
가비지 컬렉터에 의해 삭제 되게 됩니다.  

<br />

### 1-4. 가비지 컬렉터가 무엇인가?

- 자바스크립트 엔진 내부에서 실행되는 메모리 관리 기능 중 하나 입니다.

- 개발자가 직접 제어하지 않아도, 자동으로 더 이상 사용하지 않는 메모리를 해제해줍니다.

<br />

### 1-5. undefined와 null, undeclared의 차이는 무엇인가?

- undefined와 null은 공통적으로 값이 없음을 나타냅니다. 하지만 null은 다소 의도성이 포함되어 있다고 볼 수 있습니다.

- undefined는 변수가 선언되었지만, 어떠한 값도 할당되지 않았음을 의미합니다. 또한 함수 내에서 인자가 전달되지 않았을 때에도 
undefined가 할당 됩니다.

- 프로그래머가 변수에 아무것도 할당하지 않을 것임을 명시적으로 나타내거나, 객체 내에서 프로퍼티가 존재하지 않을 경우 null이 반환됩니다.

- undeclared는 변수 자체가 선언되지 않았음을 의미합니다. 변수를 선언하지 않아, referenceError가 뜨는 상황을 예시로 들 수 있습니다.

<br />

### [목차로 이동](#목차)


---
## 2. "this" 키워드의 역할은 무엇인가?  

- 현재 실행 중인 함수 또는 메서드에서 현재 객체를 참조하는 데에 사용됩니다.

- 현재 객체의 접근하거나 수정할 수 있습니다.

<br />

### 2-1. "this" 키워드가 결정되는 방식은 무엇인가?

- "this" 키워드는 호출 방식에 따라 값이 다르게 결정됩니다.

- 함수 호출에서의 "this"는 전역 객체를 의미합니다. 브라우저에서는 "window" 객체가 전역 객체를 의미합니다.

- 객체의 메서드로 호출될 때의 "this"는 해당 객체를 의미합니다.

- 생성자에서의 "this"는 새로 생성될 객체를 의미합니다.

- "apply()" 또는 "call()"에서 "this"는 함수에 전달된 첫 번째 인수로 지정된 객체를 의미합니다.

- 화살표 함수에서 "this"는 해당 함수를 둘러싸는 가장 가까운 일반 함수의 "this"를 의미합니다.

<br />

### 2-2. "apply()"와 "call()"을 차이는 무엇인가?

- 함수에 인자를 전달하는 방식에서 차이점이 있습니다.

- apply는 배열 형태로 인자를 전달합니다. (모든 인자를 하나의 배열에 모두 담아야 합니다) <br />
보통 인자의 숫자가 가변적일 때 사용합니다.

- call은 일반적인 인자를 나열하여 전달합니다. (인자를 나열하기만 하면 됩니다)

<br />

### 2-3. 화살표 함수란 무엇인가?

- ES6문법에서 등장한 새로운 함수 선언 방식입니다.

- 익명함수로 사용되며, 코드량이 줄어들고 가독성이 향상되는 이점이 있습니다.

- 하지만 "this", "arguments"등의 바인딩을 생성하지 않습니다. (상위 함수의 값을 그대로 가져옵니다.)

<br />

### 2-4. "arguments"와 "rest parameter"의 차이점은 무엇인가?

- "arguments"는 함수에 전달된 인자들을 담고 있는 유사 배열입니다. 유사 배열이므로 배열 메서드를 사용할 수 없습니다. <br />
함수내에서 "arguments" 키워드를 통해 접근할 수 있습니다. (단, 화살표 함수는 "argument" 객체가 존재하지 않습니다.)

- "rest parameter"는 인자들 중 마지막에 위치한 것을 나타내며, 인자들을 배열 형태로 전달합니다. 배열 메서드를 사용할 수 있습니다.

<br />

### [목차로 이동](#목차)

---
## 3. 클로저란 무엇이고 어떻게 사용하는가?  

- 함수가 생성될 당시의 환경을 기억하여, 해당 함수가 실행될 경우, 함수가 생성된 당시의 변수를 참조할 수 있는 기능입니다.

<br />

### 3-1. "렉시컬 스코프"란 무엇인가?

- 함수를 어디에 정의하였는지에 따라 결정되는 스코프(변수)입니다. 예를 들어 "test"라는 함수에서 정의된 변수는  <br />
"test" 스코프에 속하게 됩니다.

### 3-2. 현재 "렉시컬 스코프"에서 변수를 찾을 수 없을 경우 어떠한 동작이 일어나는가?

- 현재 "렉시컬 스코프"에서 변수를 찾을 수 없을 경우 상위(외부 함수) 스코프에서 해당 변수를 찾습니다. (스코프 체인이라 부릅니다.)  
- 만약 가장 상위의 스코프에서도 변수를 찾을 수 없을 시 참조 에러(ReferenceError)가 발생합니다.

<br />

### 3-3. 클로저를 사용했을 때의 장점은 무엇인가?

- 데이터 은닉화: 변수를 외부로부터 보호하고, 변수 값의 변경을 방지할 수 있습니다.

- 데이터 보존: 변수가 가비지 컬렉터에 의해 수집되지 않습니다. 따라서 해당 변수에 지속적인 참조가 가능합니다.

<br />

### 3-4. 클로저를 사용했을 때에 발생할 수 있는 문제점은 무엇인가?

- 메모리 누수 : 변수가 지속적인 참조가 가능함에 따라, 메모리에 계속 남아있게 됩니다. 만약 더이상 사용되지 않는 변수라면, <br />
null을 할당하여 가비지 컬렉터에 수집되게 할 수 있습니다. (더이상 참조 불가능)

```
function outerFunction() {
  let someVar = "hello";
  let anotherVar = "world";
  
  function innerFunction() {
    console.log(someVar + " " + anotherVar);
  }
  
  // 클로저를 반환하는 대신 객체를 반환
  return {
    callInnerFunction: function() {
      innerFunction();
    },
    // someVar 변수는 사용이 끝났으므로 null로 할당
    cleanup: function() {
      someVar = null;
    }
  };
}

const closureObject = outerFunction();
closureObject.callInnerFunction();
closureObject.cleanup();
```

<br />

### [목차로 이동](#목차)

---
## 4. "prototype"과 "class"의 차이점은 무엇인가?  

- 프로토타입은 객체가 상속받을 메서드와 프로퍼티를 담고 있는 객체입니다. 프로토 타입을 통해 객체 간의 상속(메서드, 프로퍼티 전달)을 할 수 있습니다. <br />
즉, 객체 간의 상속을 목적으로 한다고 볼 수 있습니다.

- 클래스는 객체 간 상속 관계를 명시적으로 나타낼 수 있습니다. 객체의 생성을 목적으로 합니다.

<br />

### 4-1. "class"와 생성자 함수의 차이는 무엇인가?

- class와 생성자 함수는 객체를 할 때 사용한다는 공통점이 있습니다. 다만, 사용하는 문법이 다릅니다.

- class는 프로퍼티를 설정할 때, constructor 메서드를 사용합니다. 상속 관계를 구현할 때에는 extends를 사용할 수 있습니다.

- 생성자 함수는 프로퍼티를 설정할 때, this 키워드를 사용합니다. 상속 관계를 구현할 때에는 prototype을 사용해야 합니다.

<br />

### 4-2. "class"를 사용하면 좋을 것 같은 경우로 예시로 들어 설명해보시오.

- 객체의 초기 값이 정해져 있을 경우 : class를 통해 초기 값을 한번 설정하면 코드의 재사용성을 높일 수 있습니다.

- 객체 간 상속이 필요할 때 : 하위 관계를 가지는 객체를 다루어야 할 경우, 그 구조를 좀 더 직관적으로 표현할 수 있습니다.

- 정적인 메서드가 필요할 때 : class 내에 메서드를 생성하여, 어떤 작업을 수행하는 지 가독성을 높일 수 있습니다. (class 명과 메서드 명을 통해 추론 가능) 

<br />

### [목차로 이동](#목차)
---
## 5. "호이스팅"은 무엇이고 어떻게 동작하는가?  

- 변수와 함수 선언이 코드 최상단에서 실행되는 현상을 말합니다.

- 변수의 경우는, 선언은 최상단에서 일어나게 되지만 이후 과정은, var 키워드 인지 혹은 const/ let 키워드인지에 따라 차이가 있습니다. <br />
var 키워드의 경우 선언과 동시에 undefined로 값 초기화가 이뤄집니다. 따라서, 변수 선언 코드보다 상단에서 해당 변수를 참조할 시 undefined를 반환합니다. <br />
const, let의 경우 값 초기화가 이뤄지지 않습니다. 따라서 참조 자체가 불가능해집니다. 

- 함수의 경우, 함수 전체가 호이스팅 되기 때문에, 함수가 선언된 위치에 관계없이 함수가 실행됩니다.

<br />

## 5-1. 함수 선언문과 함수 표현식은 무슨 차이가 있는가? 

- 두 방식은 공통적으로 함수를 "정의"하는 방법입니다.

- 함수 선언문은 호이스팅을 발생시킵니다. 따라서 함수를 어디서 정의해도 에러가 발생하지 않습니다.
```
function test() {
  console.log('함수 선언문 입니다.');
  return;
}
```

- 함수 표현식은 변수에 함수를 할당하는 방식입니다. 따라서 함수 선언이 아닌, 변수 선언의 호이스팅 사례를 따르게 됩니다. <br />
변수에 함수를 할당하므로 함수의 이름이 따로 필요하지 않습니다. 함수의 이름을 지정하지 않았을 시 익명함수라고 부르게 됩니다. <br />
```
const test = () => {
  console.log('함수 표현식 입니다.');
  return;
}
```

<br />

### [목차로 이동](#목차)

---
## 6. "비동기" 처리 방법은 무엇이 있는가?  
---
## 7. "콜백"함수는 무엇이고 어떻게 사용하는가?  
---
## 8. "Promise"는 무엇이고 어떻게 사용하는가?  
---
## 9. "async/await"는 무엇이고 어떻게 사용하는가?  
---
## 10. "ES6"의 주요 기능들은 무엇이 있는가?  
